## 隐写实现方法

### **核心原理：最低有效位（LSB）**

我们使用的隐写算法是 **最低有效位（Least Significant Bit, LSB）** 嵌入法。这是最常见也是最简单的一种数字隐写技术。

其核心思想是：数字图片是由一个个**像素**组成的，而每个像素的颜色通常由三个值来表示：**红（R）、绿（G）、蓝（B）**。每个颜色值在计算机中都是用一个8位的字节（即8个0或1）来存储的，范围从 0（纯黑）到 255（最亮）。

例如，一个纯红色的 R 值可能是 `11111111`，而一个稍暗的红色可能是 `11111110`。

“最低有效位”指的就是这8个二进制位中最右边的那一位。对于人眼来说，改变这个位（从0变1或从1变0）对颜色的影响微乎其微，几乎无法察觉。例如，`11111111`（255）和 `11111110`（254）这两种红色，肉眼看起来几乎是一模一样的。

这就为我们隐藏信息提供了可能性：**我们可以用我们想隐藏的信息的二进制位，去替换掉图片中每个颜色值的最低有效位。**

### **`steganography.js` 中的实现步骤**

我们的 `frontend/src/utils/steganography.js` 文件就是基于这个原理工作的。

#### **1. 信息编码（`hideMessage` 函数）**

1.  **准备数据**：
    *   首先，它将你要隐藏的文字（比如 "Hello"）转换成二进制码。为了支持中文和各种符号，我们使用了UTF-16编码，每个字符转换成一个16位的二进制数。例如，"H" -> `01001000`。
    *   为了知道信息在何处结束，我们在原始信息的末尾附加了一个特殊的**“哨兵”**——一个空字符 `\0`。当解码时读到这个字符，就知道信息已经全部提取完毕了。

2.  **绘制与像素操作**：
    *   函数利用HTML5的 `<canvas>` 元素在浏览器中加载你选择的图片。
    *   它通过 `ctx.getImageData()` 获取到一个包含图片所有像素数据的大数组。这个数组的结构是 `[R1, G1, B1, A1, R2, G2, B2, A2, ...]`，其中A是Alpha通道（透明度），我们不修改它。

3.  **逐位嵌入**：
    *   程序会遍历你转换好的二进制信息（比如 "H" 的 `01001000`）。
    *   对于二进制信息的**每一位**，它会依次取出像素数据数组中的一个颜色值（R, G, B），然后用这个二进制位替换掉该颜色值的最低有效位。
    *   例如，要隐藏 "1"，如果当前像素的R值是 `11111110`，它会被改成 `11111111`。要隐藏 "0"，如果R值是 `11111111`，它会被改成 `11111110`。
    *   这个过程会一直持续，直到你信息（包括哨兵）的所有二进制位都被嵌入到图片的像素中。

4.  **生成新图片**：
    *   嵌入完成后，程序用 `ctx.putImageData()` 将修改过的像素数据写回 `<canvas>`。
    *   最后，通过 `canvas.toDataURL('image/png')` 将这个带有隐藏信息的 `<canvas>` 转换成一个新的PNG图片（以Base64编码的字符串形式），并发送出去。

#### **2. 信息解码（`extractMessage` 函数）**

1.  **加载图片**：解码函数同样将接收到的图片加载到 `<canvas>` 并获取其像素数据。

2.  **逐位提取**：
    *   它遍历图片的像素数据，依次读取每个颜色值（R, G, B）的**最低有效位**。
    *   它将这些提取出来的 "0" 和 "1" 重新组合成16位的二进制串。

3.  **转换与结束**：
    *   每当收集满16位，它就将其转换回一个字符。
    *   如果转换出的字符是我们的“哨兵”（空字符 `\0`），解码过程就立即停止。
    *   最后，将所有解码出的字符拼接起来，就得到了原始的隐藏信息。

总的来说，我们利用了人眼对微小颜色变化不敏感的特点，通过修改像素中“最不重要”的二进制位，巧妙地将文本信息“藏”在了图片里。